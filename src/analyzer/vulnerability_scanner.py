from typing import Dict, Any, List, Tuple
import datetime
import re
import hashlib
import base64

class VulnerabilityScanner:
    """
    Scans JWT tokens for common security vulnerabilities.
    """
    
    # Common weak secrets that might be used in production
    COMMON_WEAK_SECRETS = [
        "secret", "password", "1234", "admin", "key", "private", 
        "weak_secret", "test", "demo", "development", "prod", "production",
        "jwt_secret", "jwt_key", "api_key", "token_secret", "app_secret",
        "supersecret", "secretkey", "private_key", "secret_key",
    ]
    
    # List of secure algorithms
    SECURE_ALGORITHMS = ["HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "ES256", "ES384", "ES512"]
    
    # List of weak algorithms
    WEAK_ALGORITHMS = ["none", "HS1", "RS1", "ES1"]
    
    def __init__(self):
        self.vulnerabilities = []
    
    def scan(self, token_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Scan a parsed JWT token for vulnerabilities.
        
        Args:
            token_data: Parsed token data from TokenParser
            
        Returns:
            List of identified vulnerabilities with severity levels
        """
        self.vulnerabilities = []
        
        # Reset vulnerabilities list
        self.vulnerabilities = []
        
        # Check for algorithm vulnerabilities
        self._check_algorithm(token_data)
        
        # Check expiration time
        self._check_expiration(token_data)
        
        # Check for missing claims
        self._check_missing_claims(token_data)
        
        # Check for weak secret key (if possible to detect)
        self._check_weak_key_indicators(token_data)
        
        # Check for excessive privileges
        self._check_privileges(token_data)
        
        # Check for sensitive data in payload
        self._check_sensitive_data(token_data)
        
        # Return all identified vulnerabilities
        return self.vulnerabilities
    
    def _check_algorithm(self, token_data: Dict[str, Any]):
        """Check for algorithm-related vulnerabilities."""
        header = token_data.get("header", {})
        alg = header.get("alg")
        
        if not alg:
            self._add_vulnerability(
                "missing_algorithm",
                "The token doesn't specify an algorithm",
                "High",
                "The JWT header is missing the 'alg' field, which is required to validate the token."
            )
            return
        
        if alg.lower() == "none":
            self._add_vulnerability(
                "none_algorithm",
                "The token uses the 'none' algorithm",
                "Critical",
                "The 'none' algorithm means the token has no signature validation, allowing attackers to forge tokens."
            )
        
        if alg not in self.SECURE_ALGORITHMS:
            if alg in self.WEAK_ALGORITHMS:
                self._add_vulnerability(
                    "weak_algorithm",
                    f"The token uses a weak algorithm: {alg}",
                    "High",
                    f"The algorithm '{alg}' is considered insecure for JWT signatures."
                )
            else:
                self._add_vulnerability(
                    "uncommon_algorithm",
                    f"The token uses an uncommon algorithm: {alg}",
                    "Medium",
                    f"The algorithm '{alg}' is not in the list of commonly used secure JWT algorithms."
                )
    
    def _check_expiration(self, token_data: Dict[str, Any]):
        """Check for expiration-related vulnerabilities."""
        payload = token_data.get("payload", {})
        is_expired = token_data.get("is_expired", False)
        expiry_time = token_data.get("expiry_time")
        
        if "exp" not in payload:
            self._add_vulnerability(
                "no_expiration",
                "The token does not have an expiration time",
                "High",
                "Without an expiration time, the token will remain valid indefinitely, "
                "increasing the risk if it gets compromised."
            )
            return
        
        if is_expired:
            self._add_vulnerability(
                "expired_token",
                "The token has expired",
                "Medium",
                "The token has passed its expiration time and should not be accepted anymore."
            )
            return
        
        # Check for excessive token lifetime
        if expiry_time and token_data.get("issue_time"):
            issue_time = token_data.get("issue_time")
            lifetime = expiry_time - issue_time
            
            if lifetime.days > 7:
                self._add_vulnerability(
                    "long_expiration",
                    f"The token has a long lifetime of {lifetime.days} days",
                    "Medium",
                    "Tokens with long lifetimes increase the window of opportunity for attackers "
                    "if the token is compromised."
                )
            elif lifetime.days > 1:
                self._add_vulnerability(
                    "moderate_expiration",
                    f"The token has a moderate lifetime of {lifetime.days} days",
                    "Low",
                    "Consider reducing token lifetime for sensitive operations."
                )
    
    def _check_missing_claims(self, token_data: Dict[str, Any]):
        """Check for missing standard claims."""
        payload = token_data.get("payload", {})
        
        # Check for recommended claims
        recommended_claims = {
            "iat": "issued at",
            "nbf": "not before",
            "jti": "JWT ID",
            "iss": "issuer",
            "aud": "audience"
        }
        
        missing_claims = []
        for claim, description in recommended_claims.items():
            if claim not in payload:
                missing_claims.append((claim, description))
        
        if missing_claims:
            claims_str = ", ".join([f"'{c}' ({d})" for c, d in missing_claims])
            self._add_vulnerability(
                "missing_claims",
                f"The token is missing recommended claims: {claims_str}",
                "Low",
                "These claims enhance token security by allowing more precise validation rules."
            )
    
    def _check_weak_key_indicators(self, token_data: Dict[str, Any]):
        """Check for indicators that suggest a weak secret key."""
        header = token_data.get("header", {})
        signature = token_data.get("signature", "")
        
        # Check signature length (shorter signatures might indicate weaker keys)
        if header.get("alg", "").startswith("HS") and len(signature) < 32:
            self._add_vulnerability(
                "short_signature",
                "The token has an unusually short signature",
                "Medium",
                "Short signatures may indicate a weak secret key was used to sign the token."
            )
        
        # Check for common signature patterns that might indicate weak keys
        decoded_sig = self._try_decode_base64(signature)
        if decoded_sig:
            for weak_secret in self.COMMON_WEAK_SECRETS:
                # This is a simplified check and may produce false positives/negatives
                if weak_secret in decoded_sig.lower():
                    self._add_vulnerability(
                        "potential_weak_key",
                        "The token signature suggests a weak secret key",
                        "High",
                        "The signature contains patterns that suggest a commonly used weak secret key."
                    )
                    break
    
    def _check_privileges(self, token_data: Dict[str, Any]):
        """Check for indicators of excessive privileges."""
        payload = token_data.get("payload", {})
        
        # Check for admin roles or elevated privileges
        role = payload.get("role", "").lower()
        roles = payload.get("roles", [])
        if isinstance(roles, str):
            roles = [roles]
        
        admin_indicators = ["admin", "superuser", "root", "system", "supervisor"]
        
        has_admin = (
            any(indicator in role for indicator in admin_indicators) or
            any(any(indicator in r.lower() for indicator in admin_indicators) for r in roles if isinstance(r, str))
        )
        
        if has_admin:
            self._add_vulnerability(
                "admin_privileges",
                "The token contains administrative privileges",
                "Medium",
                "Tokens with admin privileges should be short-lived and carefully protected. "
                "Consider using principle of least privilege."
            )
        
        # Check for wildcard permissions
        permissions = []
        for key, value in payload.items():
            if key.lower() in ["permissions", "scopes", "access", "authorities"]:
                if isinstance(value, list):
                    permissions.extend(value)
                elif isinstance(value, str):
                    permissions.append(value)
        
        wildcard_indicators = ["*", "all", "full", "fullaccess"]
        if any(any(indicator in str(p).lower() for indicator in wildcard_indicators) for p in permissions):
            self._add_vulnerability(
                "wildcard_permissions",
                "The token contains wildcard or broad permissions",
                "High",
                "Wildcard permissions grant excessive access and violate the principle of least privilege."
            )
    
    def _check_sensitive_data(self, token_data: Dict[str, Any]):
        """Check for sensitive data in the payload."""
        payload = token_data.get("payload", {})
        
        # Patterns for potentially sensitive data
        patterns = {
            "email": r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
            "credit_card": r'\b(?:\d{4}[- ]?){3}\d{4}\b',
            "social_security": r'\b\d{3}-\d{2}-\d{4}\b',
            "password": r'password|passwd|pass|pwd',
            "api_key": r'api[_-]?key|apikey|api[_-]?secret|apisecret',
            "private_key": r'private[_-]?key|privatekey|secret[_-]?key|secretkey'
        }
        
        for name, pattern in patterns.items():
            for key, value in self._flatten_dict(payload).items():
                if isinstance(value, str) and re.search(pattern, value, re.IGNORECASE):
                    self._add_vulnerability(
                        f"sensitive_{name}",
                        f"The token contains potentially sensitive {name.replace('_', ' ')} data",
                        "High",
                        f"Storing sensitive data in JWT tokens is not recommended as they are typically "
                        f"only base64 encoded, not encrypted."
                    )
    
    def _flatten_dict(self, d, parent_key='', sep='.'):
        """Flatten a nested dictionary."""
        items = []
        for k, v in d.items():
            new_key = f"{parent_key}{sep}{k}" if parent_key else k
            if isinstance(v, dict):
                items.extend(self._flatten_dict(v, new_key, sep=sep).items())
            else:
                items.append((new_key, v))
        return dict(items)
    
    def _add_vulnerability(self, id: str, title: str, severity: str, description: str):
        """Add a vulnerability to the list of findings."""
        self.vulnerabilities.append({
            "id": id,
            "title": title,
            "severity": severity,
            "description": description
        })
    
    def _try_decode_base64(self, data: str) -> str:
        """Try to decode base64 data, return empty string if it fails."""
        try:
            # Add padding if necessary
            padding_needed = len(data) % 4
            if padding_needed:
                data += '=' * (4 - padding_needed)
            
            # Replace URL-safe characters
            data = data.replace('-', '+').replace('_', '/')
            
            decoded = base64.b64decode(data).decode('utf-8', errors='ignore')
            return decoded
        except Exception:
            return ""